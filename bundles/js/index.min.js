"use strict";
console.clear();
console.log ( '%ccreated by VICTORY in Ukraine #MRPL', 'padding: 1px;background-color:#0A0B0D;color: #808080;');

// ---------------------- NOISE ---------------------- \\

const noise = () => {
    let canvas, ctx;

    let wWidth, wHeight;

    let noiseData = [];
    let frame = 0;

    let loopTimeout;


    // Create Noise
    const createNoise = () => {
        const idata = ctx.createImageData(wWidth, wHeight);
        const buffer32 = new Uint32Array(idata.data.buffer);
        const len = buffer32.length;

        for (let i = 0; i < len; i++) {
            if (Math.random() < 0.5) {
                buffer32[i] = 0xff717171;
            }
        }

        noiseData.push(idata);
    };


    // Play Noise
    const paintNoise = () => {
        if (frame === 9) {
            frame = 0;
        } else {
            frame++;
        }

        ctx.putImageData(noiseData[frame], 0, 0);
    };


    // Loop
    const loop = () => {
        paintNoise(frame);

        loopTimeout = window.setTimeout(() => {
            window.requestAnimationFrame(loop);
        }, (1000 / 15));
    };


    // Setup
    const setup = () => {
        wWidth = window.innerWidth;
        wHeight = window.innerHeight;
        // wHeight = document.querySelector('html').getBoundingClientRect().height;

        canvas.width = wWidth;
        canvas.height = wHeight;

        for (let i = 0; i < 10; i++) {
            createNoise();
        }

        loop();
    };


    // Reset
    let resizeThrottle;
    const reset = () => {
        window.addEventListener('resize', () => {
            window.clearTimeout(resizeThrottle);

            resizeThrottle = window.setTimeout(() => {
                window.clearTimeout(loopTimeout);
                setup();
            }, 200);
        }, false);
    };


    // Init
    const init = (() => {
        canvas = document.querySelector('#noise');
        ctx = canvas.getContext('2d');

        setup();
    })();
};



window.addEventListener('resize', () => {
   noise();
})

// -------------------- PRELOADER -------------------//


window.onload = function() {


    noise();
    preloaderOut();
    initAnimation();
    starterAnimation();
    // startSound();
    setTimeout(offScroll, 2000);
}

const preloaderOut = () => {

  let preload = document.querySelector('.preloader');

  preload.classList.toggle("preload_out");

  let preloaderOut = document.querySelector('.preloader__img');
  preloaderOut.classList.toggle("preload__img_out");

}



// -------------------- OFF SCROLL -------------------//

function offScroll() {
  document.querySelector('body').classList.remove("preloader_srcoll-off");


checkSound();



}

function checkSound() {
  if (!sound.isPlaying) {
    waves.waves[0].amplitude = 0;
} else {
  waves.waves[0].amplitude = 22;

}

    // document.removeEventListener("DOMContentLoaded", startSound);
};

// document.addEventListener("DOMContentLoaded", startSound);

// ---------------------- THREEJS ---------------------- \\



// let canvas = document.querySelector(".object"),
//     renderer = new THREE.WebGLRenderer({canvas});

//  renderer.setPixelRatio(window.devicePixelRatio);
//  //Фон канваса
//  renderer.setClearColor(0x202020);



// const cameraData = {
//   fov: 75, // угол обзора
//   aspect: canvas.clientWidth / canvas.clientHeight, // соотрошение сторон, убираем деформацию фигур от изменения размеров окна+ добавить в функцию анимация для вызова перерисовки сцены для динамичного отображения
//   near: 0.1, // передний план
//   far: 10000 // задний план
// };


// const camera = new THREE.PerspectiveCamera(cameraData.fov, cameraData.aspect, cameraData.near, cameraData.far);


// camera.position.x = 0;
// camera.position.y = 0;
// camera.position.z = 60;


// const scene = new THREE.Scene();

// const lightData = {
//   colors: 0xDCDBDA,
//   intensity: 1
// }

// const light = new THREE.DirectionalLight(lightData.colors, lightData.intensity);

// light.position.set(0, 150, 550);
// scene.add(light);

// // const boxWidth = 1000;
// // const boxHeight = 1000;
// // const boxDepth = 1000;
// // const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

// const geometry = new THREE.DodecahedronBufferGeometry(28, 2);

// // const material = new THREE.MeshBasicMaterial({color: 0x44aa88});

// let material = new THREE.MeshPhongMaterial({color: 0x404040, flatShading: true, wireframe: false});

// const cube = new THREE.Mesh(geometry, material);


// scene.add(cube);


// renderer.render(scene, camera);


// function render(time) {
// // cube.position.x = 40;
// // cube.position.y = 40;
// // cube.position.z = 40;
//   time *= 0.00025;  // конвертировать время в секунды

//   cube.rotation.x = time;
//   cube.rotation.y = time;

// camera.aspect = canvas.clientWidth / canvas.clientHeight;
//   camera.updateProjectionMatrix();

//   renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);

//   renderer.render(scene, camera);

//   requestAnimationFrame(render);
// }
// requestAnimationFrame(render);




// let canvas = document.querySelector(".object"),
//     renderer = new THREE.WebGLRenderer({canvas});

//  renderer.setPixelRatio(window.devicePixelRatio);
//  //Фон канваса
//  renderer.setClearColor(0x202020);


// const mouse = new THREE.Vector2();
// const target = new THREE.Vector2();
// const windowHalf = new THREE.Vector2( window.innerWidth / 2, window.innerHeight / 2 );

// document.addEventListener( 'mousemove', onMouseMove, false );
//     // document.addEventListener( 'wheel', onMouseWheel, false );
//     window.addEventListener( 'resize', onResize, false );

// function onMouseMove( event ) {

//   mouse.x = ( event.clientX - windowHalf.x );
//   mouse.y = ( event.clientY - windowHalf.x );

// }

// // function onMouseWheel( event ) {

// //   camera.position.z += event.deltaY * 0.1; // move camera along z-axis

// // }

// function onResize( event ) {

//   const width = window.innerWidth;
//   const height = window.innerHeight;

//   windowHalf.set( width / 2, height / 2 );

//   camera.aspect = width / height;
//   camera.updateProjectionMatrix();
//   renderer.setSize( width, height );

// }

//  // document.body.appendChild (renderer.domElement);



// const cameraData = {
//   fov: 75, // угол обзора
//   aspect: canvas.clientWidth / canvas.clientHeight, // соотрошение сторон, убираем деформацию фигур от изменения размеров окна+ добавить в функцию анимация для вызова перерисовки сцены для динамичного отображения
//   near: 0.1, // передний план
//   far: 10000 // задний план
// };


// const camera = new THREE.PerspectiveCamera(cameraData.fov, cameraData.aspect, cameraData.near, cameraData.far);


// // ORBIT CONTROLS
// //
// // const controls = new THREE.OrbitControls(camera, canvas);
// // controls = new THREE.OrbitControls( camera );
// // to disable zoom
// // controls.enableZoom = false;
// // to disable rotation
// // controls.enableRotate = false;
// // to disable pan
// // controls.enablePan = false;


// camera.position.x = 0;
// camera.position.y = 0;
// camera.position.z = 60;

// // create an AudioListener and add it to the camera
// const listener = new THREE.AudioListener();
// camera.add( listener );

// // create a global audio source
// const sound = new THREE.Audio( listener );

// // load a sound and set it as the Audio object's buffer
// const audioLoader = new THREE.AudioLoader();
// audioLoader.load( 'sound/background.mp3', function( buffer ) {
//   sound.setBuffer( buffer );
//   sound.setLoop( true );
//   sound.setVolume( 0.35 );
//   sound.play();
//   sound.autoplay = true;
// });

// // controls.update(); обновление положения камеры

// const scene = new THREE.Scene();

// const lightData = {
//   // colors: 0xDCDBDA,
//   colors: 0x858585,
//   intensity: 1.35,
// }

// const light = new THREE.DirectionalLight(lightData.colors, lightData.intensity);

// light.position.set(0, 150, 550);
// scene.add(light);


// // const boxWidth = 1000;
// // const boxHeight = 1000;
// // const boxDepth = 1000;
// // const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

// const geometry = new THREE.DodecahedronBufferGeometry(28, 3);

// // const material = new THREE.MeshBasicMaterial({color: 0x44aa88});

// let material = new THREE.MeshPhongMaterial({color: 0x404040, flatShading: true, wireframe: false});

// const cube = new THREE.Mesh(geometry, material);


// scene.add(cube);

// renderer.render(scene, camera);




// function render(time) {

//   time *= 0.000005;  // конвертировать время в секунды

//   // cube.rotation.x = time;
//   // cube.rotation.y = time;

// camera.aspect = canvas.clientWidth / canvas.clientHeight;
//   camera.updateProjectionMatrix();

//   renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);

//   renderer.render(scene, camera);

//   requestAnimationFrame(render);

//   // controls.update(); обновление положения камеры

//   target.x = ( 1 - mouse.x ) * 0.0009;
//   target.y = ( 1 - mouse.y ) * 0.0009;

//   // cube.rotation.x += 0.102 * ( target.y - camera.rotation.x );
//   // cube.rotation.y += 0.102 * ( target.x - camera.rotation.y );
//     cube.rotation.z += 0.012 * ( target.x - camera.rotation.y );
//     // light.position.x += 0.02 * ( target.x - camera.rotation.y );

// }
// requestAnimationFrame(render);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





// function initCanvas() {

let canvas = document.querySelector(".object"),
    renderer = new THREE.WebGLRenderer({canvas});

renderer.setPixelRatio(window.devicePixelRatio);

renderer.setClearColor(0x202020);


const cameraData = {
  fov: 75,
  aspect: canvas.clientWidth / canvas.clientHeight,
  near: 0.1,
  far: 10000
};


const camera = new THREE.PerspectiveCamera(cameraData.fov, cameraData.aspect, cameraData.near, cameraData.far);
camera.position.x = 0;
camera.position.y = 0;
camera.position.z = 20;


// create an AudioListener and add it to the camera
const listener = new THREE.AudioListener();
camera.add( listener );

// create a global audio source
const sound = new THREE.Audio( listener );

// load a sound and set it as the Audio object's buffer
const audioLoader = new THREE.AudioLoader();
audioLoader.load( 'sound/background.mp3', function( buffer ) {
  sound.setBuffer( buffer );
  sound.setLoop( true );
  sound.setVolume( 0.35 );
  sound.pause();
  sound.autoplay = true;
});


const scene = new THREE.Scene();

const lightData = {
  colors: 0x858585,
  intensity: 1.35,
}

const light = new THREE.DirectionalLight(lightData.colors, lightData.intensity);

light.position.set(0, 150, 550);
scene.add(light);


const geometry = new THREE.DodecahedronBufferGeometry(10, 2);


let material = new THREE.MeshPhongMaterial({color: 0x404040, flatShading: true, wireframe: false});



const cube = new THREE.Mesh(geometry, material);

scene.add(cube);

renderer.render(scene, camera);



function render(time) {

  time *= 0.000015;

  cube.rotation.x = time;
  cube.rotation.y = time;

  const width = window.innerWidth;
  // const width = document.querySelector('section').getBoundingClientRect().width;
  const height = window.innerHeight;
  // const height = document.querySelector('section').getBoundingClientRect().height;

  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize( width, height );


  renderer.render(scene, camera);

  requestAnimationFrame(render);

}

requestAnimationFrame(render);

// }






/*!
 _______ _____ __   _ _______      _  _  _ _______ _    _ _______ _______
 |______   |   | \  | |______      |  |  | |_____|  \  /  |______ |______
 ______| __|__ |  \_| |______      |__|__| |     |   \/   |______ ______|

 sine-waves v0.3.0 <https://github.com/isuttell/sine-waves>
 Contributor(s): Isaac Suttell <isaac@isaacsuttell.com>
 Last Build: 2014-12-03
 Do not edit this file. It is created from the src/ folder.
*/
(function(root, factory) {
  'use strict';
  if (typeof define === 'function' && typeof define.amd === 'object') {
    define([], function() {
      return factory(root);
    });
  } else {
    root.SineWaves = factory(root);
  }
})(this, function() {
  'use strict';

/************************************************
 * @file  Polyfills for older browsers
 * @author  Isaac Suttell
 ************************************************/

/**
 * Bind polyfill
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
 */
/* istanbul ignore next */
if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs = Array.prototype.slice.call(arguments, 1);
    var fToBind = this;
    var fNOP = function() {};
    var fBound = function() {
      return fToBind.apply(this instanceof fNOP &&
        oThis ? this : oThis,
        aArgs.concat(Array.prototype.slice.call(arguments)));
    };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP(); // jshint ignore:line

    return fBound;
  };
}

/**
 * Request Animation Polyfill
 * https://gist.github.com/paulirish/1579671
 *
 * @type {Array}
 */
/* istanbul ignore next */
var vendors = ['ms', 'moz', 'webkit', 'o'];
/* istanbul ignore next */
for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
  window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
  window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||
    window[vendors[x] + 'CancelRequestAnimationFrame'];
}

/* istanbul ignore next */
if (!window.requestAnimationFrame) {
  var lastFrameTime = 0;
  window.requestAnimationFrame = function(callback) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastFrameTime));
    var id = window.setTimeout(function() {
        callback(currTime + timeToCall);
      },
      timeToCall);
    lastFrameTime = currTime + timeToCall;
    return id;
  };
}

/* istanbul ignore next */
if (!window.cancelAnimationFrame) {
  window.cancelAnimationFrame = function(id) {
    clearTimeout(id);
  };
}

/************************************************
 * @file  Constants
 * @author  Isaac Suttell
 ************************************************/

/**
 * For radian conversion
 *
 * @constant
 * @type    {Number}
 */
var PI180 = Math.PI / 180;

/**
 * Twice of PI
 *
 * @constant
 * @type {Number}
 */
var PI2 = Math.PI * 2;

/**
 * Half of PI
 *
 * @constant
 * @type {Number}
 */
var HALFPI = Math.PI / 2;

/************************************************
 * @file  General utility functions
 * @author  Isaac Suttell
 ************************************************/

/**
 * Utilities wrapper
 *
 * @type    {Object}
 */
var Utilities = {};

/**
 * Checks to see if a var is a speficied type
 *
 * @param  {Mixed}  obj  var to check
 *
 * @return {Boolean}
 */
var isType = Utilities.isType = function(obj, type) {
  var result = {}.toString.call(obj).toLowerCase();
  return result === '[object ' + type.toLowerCase() + ']';
};

/**
 * Checks to see if a var is a function
 *
 * @alias  isType
 * @param  {Mixed}  fn  var to check
 *
 * @return {Boolean}
 */
var isFunction = Utilities.isFunction = function(fn) {
  return isType(fn, 'function');
};

/**
 * Checks to see if a var is a string
 *
 * @alias  isType
 * @param  {Mixed}  str  var to check
 *
 * @return {Boolean}
 */
var isString = Utilities.isString = function(str) {
  return isType(str, 'string');
};

/**
 * Checks to see if a var is a number
 *
 * @alias  isType
 * @param  {Mixed}  num  var to check
 *
 * @return {Boolean}
 */
var isNumber = Utilities.isNumber = function(num) {
  return isType(num, 'number');
};

/**
 * Create a clone of an object
 *
 * @param  {Object} src Object to clone
 *
 * @return {Object}
 */
var shallowClone = Utilities.shallowClone = function(src) {
  var dest = {};
  for (var i in src) {
    if (src.hasOwnProperty(i)) {
      dest[i] = src[i];
    }
  }
  return dest;
};

/**
 * Basic Extend Function
 *
 * @param     {Object}    dest   object to fill
 * @param     {Object}    src    object to copy
 *
 * @return    {Object}
 */
var defaults = Utilities.defaults = function(dest, src) {
  if (!isType(src, 'object')) { src = {}; }
  var clone = shallowClone(dest);
  for (var i in src) {
    if (src.hasOwnProperty(i)) {
      clone[i] = src[i];
    }
  }
  return clone;
};

/**
 * Convert degress to radians for rotation function
 *
 * @param     {Number}    degrees
 *
 * @return    {Number}
 */
var degreesToRadians = Utilities.degreesToRadians = function(degrees) {
  if (!isType(degrees, 'number')) {
    throw new TypeError('Degrees is not a number');
  }
  return degrees * PI180;
};

/**
 * You can either directly specify a easing function, use a built in function
 * or default to the basic SineInOut
 *
 * @param     {Object}   obj     Object to search in
 * @param     {Mixed}    name    String || Function
 * @param     {String}   def     Default funciton
 *
 * @return    {Function}
 */
var getFn = Utilities.getFn = function(obj, name, def) {
  if (isFunction(name)) {
    return name;
  } else if (isString(name) && isFunction(obj[name.toLowerCase()])) {
    return obj[name.toLowerCase()];
  } else {
    return obj[def];
  }
};

/************************************************
 * @file  Left to right easing functions
 * @author Isaac Suttell
 ************************************************/

/**
 * This holds all of the easing objects and can be added to by the user
 *
 * @type    {Object}
 */
var Ease = {};

/**
 * Do not apply any easing
 *
 * @param  {Number} percent   where in the line are we?
 * @param  {Number} amplitude the current strength
 *
 * @return {Number}           the new strength
 */
Ease.linear = function(percent, amplitude) {
  return amplitude;
};

/**
 * Easing function to control how string each wave is from
 * left to right
 *
 * @param  {Number} percent   where in the line are we?
 * @param  {Number} amplitude the current strength
 *
 * @return {Number}           the new strength
 */
Ease.sinein = function(percent, amplitude) {
  return amplitude * (Math.sin(percent * Math.PI - HALFPI) + 1) * 0.5;
};

/**
 * Easing function to control how string each wave is from
 * left to right
 *
 * @param  {Number} percent   where in the line are we?
 * @param  {Number} amplitude the current strength
 *
 * @return {Number}           the new strength
 */
Ease.sineout = function(percent, amplitude) {
  return amplitude * (Math.sin(percent * Math.PI + HALFPI) + 1) * 0.5;
};

/**
 * Easing function to control how string each wave is from
 * left to right
 *
 * @param  {Number} percent   where in the line are we?
 * @param  {Number} amplitude the current strength
 *
 * @return {Number}           the new strength
 */
Ease.sineinout = function(percent, amplitude) {
  return amplitude * (Math.sin(percent * PI2 - HALFPI) + 1) * 0.5;
};

/************************************************
 * @file  Sine Wave functions
 * @author Isaac Suttell
 ************************************************/

/**
 * Holds the different types of waves
 *
 * @type    {Object}
 */
var Waves = {};

/**
 * Default Sine Waves
 *
 * @param    {Number}    x
 */
Waves.sine = function(x) {
  return Math.sin(x);
};

/**
 * Alias for Sine
 *
 * @alias
 * @type    {Function}
 */
Waves.sin = Waves.sine;

/**
 * Sign polyfill
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
 *
 * @param     {Number}    x
 *
 * @return    {Number}
 */
Waves.sign = function(x) {
  x = +x; // convert to a number
  if (x === 0 || isNaN(x)) {
    return x;
  }
  return x > 0 ? 1 : -1;
};

/**
 * Square Waves
 *
 * @param    {Number}    x
 */
Waves.square = function(x) {
  return Waves.sign(Math.sin(x * PI2));
};

/**
 * Sawtooth Waves
 *
 * @param    {Number}    x
 */
Waves.sawtooth = function(x) {
  return (x - Math.floor(x + 0.5)) * 2;
};

/**
 * Triangle Waves
 *
 * @param    {Number}    x
 */
Waves.triangle = function(x) {
  return Math.abs(Waves.sawtooth(x));
};

/************************************************
 * @file  Constructor and animation controller
 * @author  Isaac Suttell
 ************************************************/

/**
 * Generates multiple customizable animated sines waves
 * using a canvas element. Supports retina displays and
 * limited mobile support
 */
function SineWaves(options) {
  // Save a reference
  this.options = Utilities.defaults(this.options, options);

  // Make sure we have a cancas
  this.el = this.options.el;
  delete this.options.el;
  if (!this.el) {
    throw 'No Canvas Selected';
  }

  // Setup the context for reference
  this.ctx = this.el.getContext('2d');

  // Do we have any waves
  this.waves = this.options.waves;
  delete this.options.waves;
  if (!this.waves || !this.waves.length) {
    throw 'No waves specified';
  }

  // DPI
  this.dpr = window.devicePixelRatio || 1;

  // Setup canvas width/heights
  this.updateDimensions();
  window.addEventListener('resize', this.updateDimensions.bind(this));

  // If the user supplied a resize event or init call it
  this.setupUserFunctions();

  // Setup Easing
  this.easeFn = Utilities.getFn(Ease, this.options.ease, 'linear');

  // Set the canvas rotation
  this.rotation = Utilities.degreesToRadians(this.options.rotate);

  // Should we start running?
  if (Utilities.isType(this.options.running, 'boolean')) {
    this.running = this.options.running;
  }

  // Assign wave functions
  this.setupWaveFns();

  // Start the magic
  this.loop();
}

/**
 * Default Options
 *
 * @type {Object}
 */
SineWaves.prototype.options = {
  speed: 10,
  rotate: 0,
  ease: 'Linear',
  wavesWidth: '95%'
};

/**
 * Get the user wave function or one of the built in functions
 */
SineWaves.prototype.setupWaveFns = function() {
  var index = -1;
  var length = this.waves.length;
  while (++index < length) {
    this.waves[index].waveFn = Utilities.getFn(Waves, this.waves[index].type, 'sine');
  }
};

/**
 * Sets up the user resize event and the initialize event
 */
SineWaves.prototype.setupUserFunctions = function() {
  // User Resize Function
  if (Utilities.isFunction(this.options.resizeEvent)) {
    this.options.resizeEvent.call(this);
    window.addEventListener('resize', this.options.resizeEvent.bind(this));
  }

  // User initialize
  if (Utilities.isFunction(this.options.initialize)) {
    this.options.initialize.call(this);
  }
};

/**
 * Defaults for each line created
 *
 * @type {Object}
 */
var defaultWave = {
  timeModifier: 1,
  amplitude: 0,
  wavelength: 0,
  segmentLength: 0,
  lineWidth: 1,
  strokeStyle: 'rgba(255, 255, 255, 0.2)',
  type: 'Sine'
};

/**
 * Takes either pixels or percents and calculates how wide the sine
 * waves should be
 *
 * @param     {Mixed}    value    0, '10px', '90%'
 * @param     {Number}   width    Width for percentages
 *
 * @return    {Number}
 */
function getWaveWidth(value, width) {
  if (Utilities.isType(value, 'number')) {
    return value;
  }

  value = value.toString();
  if (value.indexOf('%') > -1) {
    value = parseFloat(value);
    if (value > 1) {
      value /= 100;
    }
    return width * value;
  } else if (value.indexOf('px') > -1) {
    return parseInt(value, 10);
  }
}

/**
 * Get the height or width from a number, function or fallback
 * to the default client dimension
 *
 * @param    {Mixed}   dimension   This can be a function or number
 *
 * @return   {Number}
 */
SineWaves.prototype.getDimension = function(dimension) {
  if (Utilities.isNumber(this.options[dimension])) {
    return this.options[dimension];
  } else if (Utilities.isFunction(this.options[dimension])) {
    return this.options[dimension].call(this, this.el);
  } else if (dimension === 'width') {
    return this.el.clientWidth;
  } else if (dimension === 'height') {
    return this.el.clientHeight;
  }
};

/**
 * Internal resize event to make the canvas fill the screen
 */
SineWaves.prototype.updateDimensions = function() {
  // Dimensions
  var width = this.getDimension('width');
  var height = this.getDimension('height');

  // Apply DPR for retina devices
  this.width = this.el.width = width * this.dpr;
  this.height = this.el.height = height * this.dpr;

  // Scale down
  this.el.style.width = width + 'px';
  this.el.style.height = height + 'px';

  // Padding
  this.waveWidth = getWaveWidth(this.options.wavesWidth, this.width);

  // Center it
  this.waveLeft = (this.width - this.waveWidth) / 2;

  // Vertical center
  this.yAxis = this.height / 2;
};

/**
 * Clear the canvas so we can redraw
 */
SineWaves.prototype.clear = function() {
  this.ctx.clearRect(0, 0, this.width, this.height);
};

/**
 * Starting time.
 *
 * @type {Number}
 */
SineWaves.prototype.time = 0;

/**
 * This updates each of the lines each loop we're running
 *
 * @param  {Number} time (optional) this can be called to
 *                       manually render lines at a certian
 *                       time.
 */
SineWaves.prototype.update = function(time) {
  this.time = this.time - 0.007;
  if (typeof time === 'undefined') {
    time = this.time;
  }

  var index = -1;
  var length = this.waves.length;

  // Clear Canvas
  this.clear();

  this.ctx.save();

  if (this.rotation > 0) {
    this.ctx.translate(this.width / 2, this.height / 2);
    this.ctx.rotate(this.rotation);
    this.ctx.translate(-this.width / 2, -this.height / 2);
  }

  // Draw each line
  while (++index < length) {
    var timeModifier = this.waves[index].timeModifier || 1;
    this.drawWave(time * timeModifier, this.waves[index]);
  }
  this.ctx.restore();

  index = void 0;
  length = void 0;
};

/**
 * Calculate the x, y coordinates of a point in a sine wave
 *
 * @param  {Number} time     Internal time index
 * @param  {Number} position Pixels x poistion
 * @param  {Object} options  Wave options
 *
 * @return {Object}          {x, y}
 */
SineWaves.prototype.getPoint = function(time, position, options) {
  var x = (time * this.options.speed) + (-this.yAxis + position) / options.wavelength;
  var y = options.waveFn.call(this, x, Waves);

  // Left and Right Sine Easing
  var amplitude = this.easeFn.call(this, position / this.waveWidth, options.amplitude);

  x = position + this.waveLeft;
  y = amplitude * y + this.yAxis;

  return {
    x: x,
    y: y
  };
};

/**
 * Draws one line on the canvas
 *
 * @param  {Number} time    current internal clock time
 * @param  {Object} options wave options
 */
SineWaves.prototype.drawWave = function(time, options) {
  // Setup defaults
  options = Utilities.defaults(defaultWave, options);

  // Styles
  this.ctx.lineWidth = options.lineWidth * this.dpr;
  this.ctx.strokeStyle = options.strokeStyle;
  this.ctx.lineCap = 'butt';
  this.ctx.lineJoin = 'round';
  this.ctx.beginPath();

  // Starting Line
  this.ctx.moveTo(0, this.yAxis);
  this.ctx.lineTo(this.waveLeft, this.yAxis);

  var i;
  var point;

  for (i = 0; i < this.waveWidth; i += options.segmentLength) {
    // Calculate where the next point is
    point = this.getPoint(time, i, options);

    // Draw to it
    this.ctx.lineTo(point.x, point.y);

    // Clean up
    point = void 0;
  }

  // Clean  up
  i = void 0;
  options = void 0;

  // Ending Line
  this.ctx.lineTo(this.width, this.yAxis);

  // Stroke it
  this.ctx.stroke();
};

/**
 * Animation Status
 *
 * @type {Boolean}
 */
SineWaves.prototype.running = true;

/**
 * Animation Loop Controller
 */
SineWaves.prototype.loop = function() {
  if (this.running === true) {
    this.update();
  }

  window.requestAnimationFrame(this.loop.bind(this));
};

/**
 * Make the Wave functions available
 *
 * @type    {Object}
 */
SineWaves.prototype.Waves = Waves;

/**
 * Make the Ease functions available
 *
 * @type    {Object}
 */
SineWaves.prototype.Ease = Ease;
  return SineWaves;
});


























var waves = new SineWaves({
  // Canvas Element
  el: document.getElementById('waves'),

  // General speed of entire wave system
  speed: 10,

  // How many degress should we rotate all of the waves
  rotate: 0,

  // Ease function from left to right
  ease: 'SineInOut',

  // Specific how much the width of the canvas the waves should be
  // This can either be a number or a percent
  // waveWidth: '20px',

  // An array of wave options
  waves: [
    // {
    //   timeModifier: 1,
    //   lineWidth: .5,
    //   amplitude: -30,
    //   wavelength: 10,
    //   segmentLength: 3,
    // },
    {
      timeModifier: 1,
      lineWidth: 1.5,
      amplitude: 0,
      wavelength: 10,
      segmentLength: 1,
    },
  ],

  // Perform any additional initializations here
  initialize: function (){},

  // This function is called whenver the window is resized
  resizeEvent: function() {

    // Here is an example on how to create a gradient stroke
    var gradient = this.ctx.createLinearGradient(0, 0, this.width, 0);
    gradient.addColorStop(0,"rgba(0, 0, 0, 0)");
    gradient.addColorStop(0.5,"rgba(135, 135, 135, 1)");
    gradient.addColorStop(1,"rgba(0, 0, 0, 0)");

    var index = -1;
    var length = this.waves.length;
      while(++index < length){
      this.waves[index].strokeStyle = gradient;
    }
  }
});






document.querySelector('#btnwaves').style.right =  document.querySelector('#obj').getBoundingClientRect().x + "px";

document.querySelector('.header__waves_text').style.right =  document.querySelector('#obj').getBoundingClientRect().x + 100 + "px";

window.addEventListener('resize', () => {
  document.querySelector('#btnwaves').style.right =  document.querySelector('#obj').getBoundingClientRect().x + "px";
  document.querySelector('.header__waves_text').style.right =  document.querySelector('#obj').getBoundingClientRect().x + 100 + "px";
})


const attract =
  setInterval(() => {
   if (!sound.isPlaying && waves.waves[0].amplitude == 0) {
      waves.waves[0].amplitude = 22;
      waves.waves[0].wavelength = 10;
    }
  }, 7000);

  setInterval(() => {
    if (!sound.isPlaying && waves.waves[0].amplitude > 0) {
      waves.waves[0].amplitude = 0;
      waves.waves[0].wavelength = 10;
    }
  }, 7400);


// attract();

// if (!sound.isPlaying) {
//   waves.waves[0].amplitude = 0;
// }

document.querySelector('#btnwaves').addEventListener('click', () => {

  let sines = waves.waves;
  clearInterval(attract);

  if (sines[0].amplitude != 0 && sound.isPlaying) {
    sound.pause();
    checkSound()
  } else {
      sound.play();
      checkSound();
  }

})










// GSDevTools.create();

function starterAnimation() {

  Splitting();


const tl = gsap.timeline()
.add('start', .8)
  .from(document.querySelector('[data-animation-canvas]'), {
    y:"-30%",
    opacity: 0,
    duration: 1,
    stagger: {
      each: .05
    }
  }, "start")
   .from(document.querySelector('[data-animation-start-header]'), {
      y:"30%",
      opacity: 0,
      duration: .85,
      stagger: {
        each: .05
      }
    }, "start+=.75")
    .from(document.querySelectorAll('[data-animation-start-subtitle] .char'), {
      opacity: 0,
      y: "80%",
      duration: .65,
      stagger: {
        each: .0030
      }
    }, "start+=1.05")
    .from(document.querySelectorAll('[data-animation-start-text] .char'), {
      duration: .5,
      y: "80%",
      opacity: 0,
      stagger: {
        each: .0015
     }
  }, "start+=1.15")
}

function initAnimation() {
gsap.registerPlugin(ScrollTrigger);
Splitting();


const locoScroll = new LocomotiveScroll({
  el: document.querySelector("[data-scroll-container]"),
  smooth: true,
  lerp: .05
});


locoScroll.on("scroll", ScrollTrigger.update);


ScrollTrigger.scrollerProxy("[data-scroll-container]", {
  scrollTop(value) {
    return arguments.length ? locoScroll.scrollTo(value, 0, 0) : locoScroll.scroll.instance.scroll.y;
  },
  getBoundingClientRect() {
    return {top: 0, left: 0, width: window.innerWidth, height: window.innerHeight};
  },

  pinType: document.querySelector("[data-scroll-container]").style.transform ? "transform" : "fixed"
});





// const animationIn = function() {

  let section = document.querySelectorAll('[data-animation-section]');


  section.forEach(item => {


    const tl = gsap.timeline({
      paused: true,
      defaults: {
      ease: "power2.Out",
      }
    })
    .add('startPosition', 0)
    .from(item.querySelector('[data-animation-header]'), {
      y:"30%",
      opacity: 0,
      duration: .75,
      stagger: {
        each: .05
      }
    }, "startPosition")
    .from(item.querySelectorAll('[data-animation-subtitle] .char'), {
      opacity: 0,
      y: "80%",
      duration: .55,
      stagger: {
        each: .0030
      }
    }, "startPosition+=.4")
    .from(item.querySelectorAll('[data-animation-text] .char'), {
      duration: .55,
      y: "80%",
      opacity: 0,
      stagger: {
        each: .002
     }
  }, "startPosition+=.65")
  .from(item.querySelectorAll('[data-animation-folio]'), {
    duration: .85,
    y: "25%",
    opacity: 0,
    stagger: {
      each: .1,
      from: "random"
    },
    ease: "back.inOut(1.7)"
  }, 0)
  // .from(item.querySelector('[data-animation-canvas]'), {
  //   y:"-30%",
  //   opacity: 0,
  //   duration: 1.25,
  //   stagger: {
  //     each: .05
  //   }
  // }, "startPosition+=1.5")

  ScrollTrigger.create({
    animation: tl,
    trigger: item,
    start: "top center-=150px",
  })
  })



// gsap.from(document.querySelector('[data-animation-canvas]'), {
//     y:"-30%",
//     opacity: 0,
//     duration: 1.05,
//     ease: "back.inOut(1.7)"
//   }, .25)

ScrollTrigger.addEventListener("refresh", () => locoScroll.update());
ScrollTrigger.refresh();
}
