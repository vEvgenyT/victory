"use strict";
console.clear();
console.log ( '%ccreated by VICTORY in Ukraine #MRPL', 'padding: 1px;background-color:#0A0B0D;color: #808080;');

// -------------------- OFF SCROLL -------------------//

function offScroll() {
  document.querySelector('body').classList.remove("preloader_srcoll-off");
}

// -------------------- PRELOADER -------------------//

window.onload = function() {

    let preload = document.querySelector('.preloader');

    preload.classList.toggle("preload_out");

    let preloaderOut = document.querySelector('.preloader__img');
    preloaderOut.classList.toggle("preload__img_out");

    noise();
    setTimeout(offScroll, 2000);
}

// ---------------------- NOISE ---------------------- \\

const noise = () => {
    let canvas, ctx;

    let wWidth, wHeight;

    let noiseData = [];
    let frame = 0;

    let loopTimeout;


    // Create Noise
    const createNoise = () => {
        const idata = ctx.createImageData(wWidth, wHeight);
        const buffer32 = new Uint32Array(idata.data.buffer);
        const len = buffer32.length;

        for (let i = 0; i < len; i++) {
            if (Math.random() < 0.5) {
                buffer32[i] = 0xff717171;
            }
        }

        noiseData.push(idata);
    };


    // Play Noise
    const paintNoise = () => {
        if (frame === 9) {
            frame = 0;
        } else {
            frame++;
        }

        ctx.putImageData(noiseData[frame], 0, 0);
    };


    // Loop
    const loop = () => {
        paintNoise(frame);

        loopTimeout = window.setTimeout(() => {
            window.requestAnimationFrame(loop);
        }, (1000 / 15));
    };


    // Setup
    const setup = () => {
        wWidth = window.innerWidth;
        wHeight = window.innerHeight;
        // wHeight = document.querySelector('html').getBoundingClientRect().height;

        canvas.width = wWidth;
        canvas.height = wHeight;

        for (let i = 0; i < 10; i++) {
            createNoise();
        }

        loop();
    };


    // Reset
    let resizeThrottle;
    const reset = () => {
        window.addEventListener('resize', () => {
            window.clearTimeout(resizeThrottle);

            resizeThrottle = window.setTimeout(() => {
                window.clearTimeout(loopTimeout);
                setup();
            }, 200);
        }, false);
    };


    // Init
    const init = (() => {
        canvas = document.querySelector('#noise');
        ctx = canvas.getContext('2d');

        setup();
    })();
};

// -------------------- ANIMATION -------------------//

Splitting();

  // window.onload = function() {
    // let preload = document.querySelector('.preloader');

    // preload.classList.toggle("preload_out");
    // noise();



// Получил массив для заголовков
let subtitle = gsap.utils.toArray(document.querySelectorAll('#subtitle .word > .char, whitespace')),

// Получил массив для основного текста
    paragraph = gsap.utils.toArray(document.querySelectorAll('#paragraph .word > .char')),

// Получил массив для объектов
    obj = gsap.utils.toArray(document.querySelectorAll('#obj')),
    nav = gsap.utils.toArray(document.querySelectorAll('#nav .word > .char')),
    folio = gsap.utils.toArray(document.querySelectorAll('#folio')),
    title = gsap.utils.toArray(document.querySelectorAll('#title'));



// Переменные тайминга
const timelineSettings = {
    staggerValue: 0.01,
    charsDuration: 0.5
};

let tl = gsap.timeline({
    // repeat: -1,
    scrollTrigger: {
      trigger: title,
      start: "top bottom",
    }
})

// Анимация объектов
.from( obj, {
  y:"150%",
  opacity: 0,
  duration: 1.8,
  stagger: {
      each: .35,
    },
  ease: "elastic.out(1, 1.5)"
}, "+=.75")
.to ( obj , {
  y: 0,
  opacity: 1,
})

// Анимация заголовков
.from( title, {
  y:"50%",
  opacity: 0,
  scaleX: 1.8,
  duration: 1.4,
  ease: "back.out(0.75)"
}, "-=1.55")
.to ( title, {
  y: 0,
  opacity: 1,
})


// Анимация подзаголовков
  .from( subtitle, {
    y:'100%',
    stagger: timelineSettings.staggerValue,
    opacity: 0,
    ease: 'Power3.easeOut'
  }, "-=.8")
  .to( subtitle, {
    y:0,
    stagger: timelineSettings.staggerValue,
    opacity: 1,
  })

// Анимация основного текста
.from( paragraph, {
    y:'100%',
      rotateX: -160,
    stagger: {
      each: 0.0035,
    },
    opacity: 0,
    ease: 'Power3.easeOut'
  }, "-=.75")
  .to( paragraph, {
    y:0,
    opacity: 1,
  })



// Анимация ссылок
.from( nav, {
    y:'-100%',
  rotateX: "-180",
  duration: 0.75,
    stagger: {
      each: 0.01,
    },
    opacity: 0,
    ease: 'Power3.easeOut'
  }, "-=1.65")
  .to( nav, {
    y:0,
    rotateX: 0,
    stagger: {
      each: 0.01,
    },
    opacity: 1,
  })


  // }
  //
  //
  //
  // Анимация портфолио
  let rnd = gsap.utils.random(0, 30, 5);
  let timeline = gsap.timeline({
    scrollTrigger: {
      trigger: folio,
      // pin: "#pinned",
      // scrub: true,
      start: "top center",
      // end: "+=120%",

      // onUpdate: ({progress}) => timeline.progress() < progress ? timeline.progress(progress) : null
    },
})

// Анимация картинок
.from( folio, {
  y:rnd,
  scale: 0,
  opacity: 0,
  duration: 2.5,
  stagger: {
      each: .15,
      from: "top",
    },
  ease: "elastic.out(1, 1.25)"
});




let serviceTitle = gsap.utils.toArray(document.querySelectorAll('#serviceTitle'));
let serviceSubtitle = gsap.utils.toArray(document.querySelectorAll('#serviceSubtitle .word > .char, whitespace')),

// Получил массив для основного текста
    serviceParagraph = gsap.utils.toArray(document.querySelectorAll('#serviceParagraph .word > .char'));

let service = gsap.timeline({
    // repeat: -1,
    scrollTrigger: {
      trigger: serviceTitle,
      start: "top center",
      // markers: true
    }
})
.from( serviceTitle, {
  y:"50%",
  opacity: 0,
  scaleX: 1.8,
  duration: 1.4,
  ease: "back.out(0.75)"
})
.to ( serviceTitle, {
  y: 0,
  opacity: 1,
})
// Анимация подзаголовков
  .from( serviceSubtitle, {
    y:'100%',
    stagger: timelineSettings.staggerValue,
    opacity: 0,
    ease: 'Power3.easeOut'
  }, "-=1")
  .to( serviceSubtitle, {
    y:0,
    stagger: timelineSettings.staggerValue,
    opacity: 1,
  })

// Анимация основного текста
.from( serviceParagraph, {
    y:'100%',
      rotateX: -160,
    stagger: {
      each: 0.0035,
    },
    opacity: 0,
    ease: 'Power3.easeOut'
  }, "-=1.75")
  .to( serviceParagraph, {
    y:0,
    opacity: 1,
  });







  let stagesTitle = gsap.utils.toArray(document.querySelectorAll('#stagesTitle'));
let stagesSubtitle = gsap.utils.toArray(document.querySelectorAll('#stagesSubtitle .word > .char, whitespace')),

// Получил массив для основного текста
    stagesParagraph = gsap.utils.toArray(document.querySelectorAll('#stagesParagraph .word > .char'));

let stages = gsap.timeline({
    // repeat: -1,
    scrollTrigger: {
      trigger: stagesTitle,
      start: "top center",
      // markers: true
    }
})
.from( stagesTitle, {
  y:"50%",
  opacity: 0,
  scaleX: 1.8,
  duration: 1.4,
  ease: "back.out(0.75)"
})
.to ( stagesTitle, {
  y: 0,
  opacity: 1,
})
// Анимация подзаголовков
  .from( stagesSubtitle, {
    y:'100%',
    stagger: timelineSettings.staggerValue,
    opacity: 0,
    ease: 'Power3.easeOut'
  }, "-=1")
  .to( stagesSubtitle, {
    y:0,
    stagger: timelineSettings.staggerValue,
    opacity: 1,
  })

// Анимация основного текста
.from( stagesParagraph, {
    y:'100%',
      rotateX: -160,
    stagger: {
      each: 0.0035,
    },
    opacity: 0,
    ease: 'Power3.easeOut'
  }, "-=1.75")
  .to( stagesParagraph, {
    y:0,
    opacity: 1,
  })

// -------------------- CHECKBOX -------------------//

// let checkbox = document.querySelector("#checkbox");

// checkbox.addEventListener( 'change', function() {
//   if(this.checked) {
//     document.querySelector(".aside").classList.toggle('aside_checked');
//     document.querySelector(".index-title__contacts_style").innerHTML = 'Закрыть';
//   } else {
//       document.querySelector(".aside").classList.toggle('aside_checked');
//     document.querySelector(".index-title__contacts_style").innerHTML = 'Контакты';
//     }
// });

// ---------------------- THREEJS ---------------------- \\



// let canvas = document.querySelector(".object"),
//     renderer = new THREE.WebGLRenderer({canvas});

//  renderer.setPixelRatio(window.devicePixelRatio);
//  //Фон канваса
//  renderer.setClearColor(0x202020);



// const cameraData = {
//   fov: 75, // угол обзора
//   aspect: canvas.clientWidth / canvas.clientHeight, // соотрошение сторон, убираем деформацию фигур от изменения размеров окна+ добавить в функцию анимация для вызова перерисовки сцены для динамичного отображения
//   near: 0.1, // передний план
//   far: 10000 // задний план
// };


// const camera = new THREE.PerspectiveCamera(cameraData.fov, cameraData.aspect, cameraData.near, cameraData.far);


// camera.position.x = 0;
// camera.position.y = 0;
// camera.position.z = 60;


// const scene = new THREE.Scene();

// const lightData = {
//   colors: 0xDCDBDA,
//   intensity: 1
// }

// const light = new THREE.DirectionalLight(lightData.colors, lightData.intensity);

// light.position.set(0, 150, 550);
// scene.add(light);

// // const boxWidth = 1000;
// // const boxHeight = 1000;
// // const boxDepth = 1000;
// // const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

// const geometry = new THREE.DodecahedronBufferGeometry(28, 2);

// // const material = new THREE.MeshBasicMaterial({color: 0x44aa88});

// let material = new THREE.MeshPhongMaterial({color: 0x404040, flatShading: true, wireframe: false});

// const cube = new THREE.Mesh(geometry, material);


// scene.add(cube);


// renderer.render(scene, camera);


// function render(time) {
// // cube.position.x = 40;
// // cube.position.y = 40;
// // cube.position.z = 40;
//   time *= 0.00025;  // конвертировать время в секунды

//   cube.rotation.x = time;
//   cube.rotation.y = time;

// camera.aspect = canvas.clientWidth / canvas.clientHeight;
//   camera.updateProjectionMatrix();

//   renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);

//   renderer.render(scene, camera);

//   requestAnimationFrame(render);
// }
// requestAnimationFrame(render);





let canvas = document.querySelector(".object"),
    renderer = new THREE.WebGLRenderer({canvas});

 renderer.setPixelRatio(window.devicePixelRatio);
 //Фон канваса
 renderer.setClearColor(0x202020);


const mouse = new THREE.Vector2();
const target = new THREE.Vector2();
const windowHalf = new THREE.Vector2( window.innerWidth / 2, window.innerHeight / 2 );

document.addEventListener( 'mousemove', onMouseMove, false );
    // document.addEventListener( 'wheel', onMouseWheel, false );
    window.addEventListener( 'resize', onResize, false );

function onMouseMove( event ) {

  mouse.x = ( event.clientX - windowHalf.x );
  mouse.y = ( event.clientY - windowHalf.x );

}

// function onMouseWheel( event ) {

//   camera.position.z += event.deltaY * 0.1; // move camera along z-axis

// }

function onResize( event ) {

  const width = window.innerWidth;
  const height = window.innerHeight;

  windowHalf.set( width / 2, height / 2 );

  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize( width, height );

}

 // document.body.appendChild (renderer.domElement);



const cameraData = {
  fov: 75, // угол обзора
  aspect: canvas.clientWidth / canvas.clientHeight, // соотрошение сторон, убираем деформацию фигур от изменения размеров окна+ добавить в функцию анимация для вызова перерисовки сцены для динамичного отображения
  near: 0.1, // передний план
  far: 10000 // задний план
};


const camera = new THREE.PerspectiveCamera(cameraData.fov, cameraData.aspect, cameraData.near, cameraData.far);


// ORBIT CONTROLS
//
// const controls = new THREE.OrbitControls(camera, canvas);
// controls = new THREE.OrbitControls( camera );
// to disable zoom
// controls.enableZoom = false;
// to disable rotation
// controls.enableRotate = false;
// to disable pan
// controls.enablePan = false;


camera.position.x = 0;
camera.position.y = 0;
camera.position.z = 60;

// controls.update(); обновление положения камеры

const scene = new THREE.Scene();

const lightData = {
  colors: 0xDCDBDA,
  intensity: 1
}

const light = new THREE.DirectionalLight(lightData.colors, lightData.intensity);

light.position.set(0, 150, 550);
scene.add(light);

// const boxWidth = 1000;
// const boxHeight = 1000;
// const boxDepth = 1000;
// const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

const geometry = new THREE.DodecahedronBufferGeometry(28, 3);

// const material = new THREE.MeshBasicMaterial({color: 0x44aa88});

let material = new THREE.MeshPhongMaterial({color: 0x404040, flatShading: true, wireframe: false});

const cube = new THREE.Mesh(geometry, material);


scene.add(cube);


renderer.render(scene, camera);




function render(time) {

  time *= 0.000005;  // конвертировать время в секунды

  cube.rotation.x = time;
  cube.rotation.y = time;

camera.aspect = canvas.clientWidth / canvas.clientHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);

  renderer.render(scene, camera);

  requestAnimationFrame(render);

  // controls.update(); обновление положения камеры

  target.x = ( 1 - mouse.x ) * 0.0009;
  target.y = ( 1 - mouse.y ) * 0.0009;

  // cube.rotation.x += 0.102 * ( target.y - camera.rotation.x );
  // cube.rotation.y += 0.102 * ( target.x - camera.rotation.y );
    cube.rotation.z += 0.02 * ( target.x - camera.rotation.y );

}
requestAnimationFrame(render);

// -------------------- BUTTON -------------------//
//
//
// utils
// Map number x from range [a, b] to [c, d]
const map = (x, a, b, c, d) => (x - a) * (d - c) / (b - a) + c;

// Linear interpolation
const lerp = (a, b, n) => (1 - n) * a + n * b;

const calcWinsize = () => {
    return {width: window.innerWidth, height: window.innerHeight};
};

// Gets the mouse position
const getMousePos = (e) => {
    let posx = 0;
    let posy = 0;
    if (!e) e = window.event;
    if (e.pageX || e.pageY) {
        posx = e.pageX;
        posy = e.pageY;
    }
    else if (e.clientX || e.clientY)    {
        posx = e.clientX + body.scrollLeft + document.documentElement.scrollLeft;
        posy = e.clientY + body.scrollTop + document.documentElement.scrollTop;
    }

    return { x : posx, y : posy }
};

const distance = (x1,y1,x2,y2) => {
    var a = x1 - x2;
    var b = y1 - y2;

    return Math.hypot(a,b);
}

// Generate a random float.
const getRandomFloat = (min, max) => (Math.random() * (max - min) + min).toFixed(2);


// btnCtrl
// Calculate the viewport size
let winsize = calcWinsize();
window.addEventListener('resize', () => winsize = calcWinsize());

// Track the mouse position
let mousepos = {x: 0, y: 0};
window.addEventListener('mousemove', ev => mousepos = getMousePos(ev));

class ButtonCtrl extends EventEmitter {
    constructor(el) {
        super();
        // DOM elements
        // el: main button
        // text: inner text element
        this.DOM = {el: el};
        this.DOM.text = this.DOM.el.querySelector('.button__text');
        this.DOM.textinner = this.DOM.el.querySelector('.button__text-inner');
        this.DOM.decoTop = this.DOM.el.querySelector('.button__deco--1');
        this.DOM.decoBottom = this.DOM.el.querySelector('.button__deco--2');
        // amounts the button will translate/scale
        this.renderedStyles = {
            tx: {previous: 0, current: 0, amt: 0.1},
            ty: {previous: 0, current: 0, amt: 0.1},
            tx2: {previous: 0, current: 0, amt: 0.05},
            ty2: {previous: 0, current: 0, amt: 0.05}
        };

        // button state (hover)
        this.state = {
            hover: false
        };
        // calculate size/position
        this.calculateSizePosition();
        // init events
        this.initEvents();
        // loop fn
        requestAnimationFrame(() => this.render());
    }
    calculateSizePosition() {
        // size/position
        this.rect = this.DOM.el.getBoundingClientRect();
        // the movement will take place when the distance from the mouse to the center of the button is lower than this value
        this.distanceToTrigger = this.rect.width*1.5;
    }
    initEvents() {
        this.onResize = () => this.calculateSizePosition();
        window.addEventListener('resize', this.onResize);
    }
    render() {
        // calculate the distance from the mouse to the center of the button
        const distanceMouseButton = distance(mousepos.x, mousepos.y, this.rect.left + this.rect.width/2, this.rect.top + this.rect.height/2);
        // new values for the translations and scale
        let x = 0;
        let y = 0;

        if ( distanceMouseButton < this.distanceToTrigger ) {
            if ( !this.state.hover ) {
                this.enter();
            }
            x = (mousepos.x - (this.rect.left + this.rect.width/2))*.3;
            y = (mousepos.y - (this.rect.top + this.rect.height/2))*.3;
        }
        else if ( this.state.hover ) {
            this.leave();
        }

        this.renderedStyles['tx'].current = this.renderedStyles['tx2'].current = x;
        this.renderedStyles['ty'].current = this.renderedStyles['ty2'].current = y;

        for (const key in this.renderedStyles ) {
            this.renderedStyles[key].previous = lerp(this.renderedStyles[key].previous, this.renderedStyles[key].current, this.renderedStyles[key].amt);
        }

        this.DOM.decoTop.style.transform = `translate3d(${this.renderedStyles['tx'].previous}px, ${this.renderedStyles['ty'].previous}px, 0)`;
        this.DOM.decoBottom.style.transform = `translate3d(${this.renderedStyles['tx2'].previous}px, ${this.renderedStyles['ty2'].previous}px, 0)`;
        this.DOM.text.style.transform = `translate3d(${this.renderedStyles['tx'].previous*0.5}px, ${this.renderedStyles['ty'].previous*0.5}px, 0)`;



        requestAnimationFrame(() => this.render());
    }
    enter() {
        this.emit('enter');
        this.state.hover = true;

        this.DOM.el.classList.add('button--hover');
        document.body.classList.add('active');

        gsap.killTweensOf(document.body);
        gsap.killTweensOf(this.DOM.textinner);

let targets = gsap.utils.toArray(this.DOM.textinner);
        gsap
        .timeline()
        // .to(document.body, 0.2, {backgroundColor: '#000'})
        .to(targets, 0.1, {
            ease: 'Power3.easeOut',
            opacity: 0,
            y: '-10%'
        }, 0)
        .to(targets, 0.2, {
            ease: 'Expo.easeOut',
            opacity: 1,
            startAt: {y: '20%'},
            y: '0%'
        });
    }
    leave() {
        this.emit('leave');
        this.state.hover = false;

        this.DOM.el.classList.remove('button--hover');
        document.body.classList.remove('active');

        gsap.killTweensOf(document.body);
        gsap.killTweensOf(this.DOM.textinner);

        gsap
        .timeline()
        // .to(document.body, 0.2, {backgroundColor: bodyColor})
        .to(this.DOM.textinner, 0.1, {
            ease: 'Power3.easeOut',
            opacity: 0,
            y: '10%'
        }, 0)
        .to(this.DOM.textinner, 0.2, {
            ease: 'Expo.easeOut',
            opacity: 1,
            startAt: {y: '-20%'},
            y: '0%'
        });
    }
}


const button = new ButtonCtrl(document.querySelector('.button'));

// ----------------------------------------------------------------------------
// Buzz, a Javascript HTML5 Audio library
// Licensed under the MIT license.
// http://buzz.jaysalvat.com/
// ----------------------------------------------------------------------------
// Copyright (C) Jay Salvat
// http://jaysalvat.com/
// ----------------------------------------------------------------------------
/* jshint browser: true, node: true */
/* global define */

(function (context, factory) {
    "use strict";

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else {
        context.buzz = factory();
    }
})(this, function () {
    "use strict";

    var AudioContext = window.AudioContext || window.webkitAudioContext;

    var buzz = {
        defaults: {
            autoplay: false,
            crossOrigin: null,
            duration: 5000,
            formats: [],
            loop: false,
            placeholder: '--',
            preload: 'metadata',
            volume: 80,
            webAudioApi: false,
            document: window.document // iframe support
        },
        types: {
            'mp3': 'audio/mpeg',
            'ogg': 'audio/ogg',
            'wav': 'audio/wav',
            'aac': 'audio/aac',
            'm4a': 'audio/x-m4a'
        },
        sounds: [],
        el: document.createElement('audio'),

        getAudioContext: function() {
            if (this.audioCtx === undefined) {
                try {
                    this.audioCtx = AudioContext ? new AudioContext() : null;
                } catch (e) {
                    // There is a limit to how many contexts you can have, so fall back in case of errors constructing it
                    this.audioCtx = null;
                }
            }

            return this.audioCtx;
        },

        sound: function (src, options) {
            options = options || {};

            var doc = options.document || buzz.defaults.document;

            var pid = 0,
                events = [],
                eventsOnce = {},
                supported = buzz.isSupported();

            // publics
            this.load = function () {
                if (!supported) {
                    return this;
                }

                this.sound.load();

                return this;
            };

            this.play = function () {
                if (!supported) {
                    return this;
                }

                this.sound.play().catch(function () {});

                return this;
            };

            this.togglePlay = function () {
                if (!supported) {
                    return this;
                }

                if (this.sound.paused) {
                    this.sound.play().catch(function () {});
                } else {
                    this.sound.pause();
                }

                return this;
            };

            this.pause = function () {
                if (!supported) {
                    return this;
                }

                this.sound.pause();

                return this;
            };

            this.isPaused = function () {
                if (!supported) {
                    return null;
                }

                return this.sound.paused;
            };

            this.stop = function () {
                if (!supported ) {
                    return this;
                }

                this.sound.pause();
                this.setTime(0);

                return this;
            };

            this.isEnded = function () {
                if (!supported) {
                    return null;
                }

                return this.sound.ended;
            };

            this.loop = function () {
                if (!supported) {
                    return this;
                }

                this.sound.loop = 'loop';
                this.bind('ended.buzzloop', function () {
                    this.currentTime = 0;
                    this.play();
                });

                return this;
            };

            this.unloop = function () {
                if (!supported) {
                    return this;
                }

                this.sound.removeAttribute('loop');
                this.unbind('ended.buzzloop');

                return this;
            };

            this.mute = function () {
                if (!supported) {
                    return this;
                }

                this.sound.muted = true;

                return this;
            };

            this.unmute = function () {
                if (!supported) {
                    return this;
                }

                this.sound.muted = false;

                return this;
            };

            this.toggleMute = function () {
                if (!supported) {
                    return this;
                }

                this.sound.muted = !this.sound.muted;

                return this;
            };

            this.isMuted = function () {
                if (!supported) {
                    return null;
                }

                return this.sound.muted;
            };

            this.setVolume = function (volume) {
                if (!supported) {
                    return this;
                }

                if (volume < 0) {
                    volume = 0;
                }
                if (volume > 100) {
                    volume = 100;
                }

                this.volume = volume;
                this.sound.volume = volume / 100;

                return this;
            };

            this.getVolume = function () {
                if (!supported) {
                    return this;
                }

                return this.volume;
            };

            this.increaseVolume = function (value) {
                return this.setVolume(this.volume + (value || 1));
            };

            this.decreaseVolume = function (value) {
                return this.setVolume(this.volume - (value || 1));
            };

            this.setTime = function (time) {
                if (!supported) {
                    return this;
                }

                var set = true;
                this.whenReady(function () {
                    if (set === true) {
                        set = false;
                        this.sound.currentTime = time;
                    }
                });

                return this;
            };

            this.getTime = function () {
                if (!supported) {
                    return null;
                }

                var time = Math.round(this.sound.currentTime * 100) / 100;

                return isNaN(time) ? buzz.defaults.placeholder : time;
            };

            this.setPercent = function (percent) {
                if (!supported) {
                    return this;
                }

                return this.setTime(buzz.fromPercent(percent, this.sound.duration));
            };

            this.getPercent = function () {
                if (!supported) {
                    return null;
                }

                var percent = Math.round(buzz.toPercent(this.sound.currentTime, this.sound.duration));

                return isNaN(percent) ? buzz.defaults.placeholder : percent;
            };

            this.setSpeed = function (duration) {
                if (!supported) {
                    return this;
                }

                this.sound.playbackRate = duration;

                return this;
            };

            this.getSpeed = function () {
                if (!supported) {
                    return null;
                }

                return this.sound.playbackRate;
            };

            this.getDuration = function () {
                if (!supported) {
                    return null;
                }

                var duration = Math.round(this.sound.duration * 100) / 100;

                return isNaN(duration) ? buzz.defaults.placeholder : duration;
            };

            this.getPlayed = function () {
                if (!supported) {
                    return null;
                }

                return timerangeToArray(this.sound.played);
            };

            this.getBuffered = function () {
                if (!supported) {
                    return null;
                }

                return timerangeToArray(this.sound.buffered);
            };

            this.getSeekable = function () {
                if (!supported) {
                    return null;
                }

                return timerangeToArray(this.sound.seekable);
            };

            this.getErrorCode = function () {
                if (supported && this.sound.error) {
                    return this.sound.error.code;
                }

                return 0;
            };

            this.getErrorMessage = function () {
                if (!supported) {
                    return null;
                }

                switch(this.getErrorCode()) {
                    case 1:
                        return 'MEDIA_ERR_ABORTED';
                    case 2:
                        return 'MEDIA_ERR_NETWORK';
                    case 3:
                        return 'MEDIA_ERR_DECODE';
                    case 4:
                        return 'MEDIA_ERR_SRC_NOT_SUPPORTED';
                    default:
                        return null;
                }
            };

            this.getStateCode = function () {
                if (!supported) {
                    return null;
                }

                return this.sound.readyState;
            };

            this.getStateMessage = function () {
                if (!supported) {
                    return null;
                }

                switch(this.getStateCode()) {
                    case 0:
                        return 'HAVE_NOTHING';
                    case 1:
                        return 'HAVE_METADATA';
                    case 2:
                        return 'HAVE_CURRENT_DATA';
                    case 3:
                        return 'HAVE_FUTURE_DATA';
                    case 4:
                        return 'HAVE_ENOUGH_DATA';
                    default:
                        return null;
                }
            };

            this.getNetworkStateCode = function () {
                if (!supported) {
                    return null;
                }

                return this.sound.networkState;
            };

            this.getNetworkStateMessage = function () {
                if (!supported) {
                    return null;
                }

                switch(this.getNetworkStateCode()) {
                    case 0:
                        return 'NETWORK_EMPTY';
                    case 1:
                        return 'NETWORK_IDLE';
                    case 2:
                        return 'NETWORK_LOADING';
                    case 3:
                        return 'NETWORK_NO_SOURCE';
                    default:
                        return null;
                }
            };

            this.set = function (key, value) {
                if (!supported) {
                    return this;
                }

                this.sound[key] = value;

                return this;
            };

            this.get = function (key) {
                if (!supported) {
                  return null;
                }

                return key ? this.sound[key] : this.sound;
            };

            this.bind = function (types, func) {
                if (!supported) {
                    return this;
                }

                types = types.split(' ');

                var self = this,
                    efunc = function (e) { func.call(self, e); };

                for (var t = 0; t < types.length; t++) {
                    var type = types[t],
                        idx = type;
                        type = idx.split('.')[0];

                        events.push({ idx: idx, func: efunc });
                        this.sound.addEventListener(type, efunc, true);
                }

                return this;
            };

            this.unbind = function (types) {
                if (!supported) {
                    return this;
                }

                types = types.split(' ');

                for (var t = 0; t < types.length; t++) {
                    var idx = types[t],
                        type = idx.split('.')[0];

                    for (var i = 0; i < events.length; i++) {
                        var namespace = events[i].idx.split('.');
                        if (events[i].idx === idx || (namespace[1] && namespace[1] === idx.replace('.', ''))) {
                            this.sound.removeEventListener(type, events[i].func, true);
                            // remove event
                            events.splice(i, 1);
                        }
                    }
                }

                return this;
            };

            this.bindOnce = function (type, func) {
                if (!supported) {
                    return this;
                }

                var self = this;

                eventsOnce[pid++] = false;
                this.bind(type + '.' + pid, function () {
                   if (!eventsOnce[pid]) {
                       eventsOnce[pid] = true;
                       func.call(self);
                   }
                   self.unbind(type + '.' + pid);
                });

                return this;
            };

            this.trigger = function (types, detail) {
                if (!supported) {
                    return this;
                }

                types = types.split(' ');

                for (var t = 0; t < types.length; t++) {
                    var idx = types[t];

                    for (var i = 0; i < events.length; i++) {
                        var eventType = events[i].idx.split('.');

                        if (events[i].idx === idx || (eventType[0] && eventType[0] === idx.replace('.', ''))) {
                            var evt = doc.createEvent('HTMLEvents');

                            evt.initEvent(eventType[0], false, true);

                            evt.originalEvent = detail;

                            this.sound.dispatchEvent(evt);
                        }
                    }
                }

                return this;
            };

            this.fadeTo = function (to, duration, callback) {
                if (!supported) {
                    return this;
                }

                if (duration instanceof Function) {
                    callback = duration;
                    duration = buzz.defaults.duration;
                } else {
                    duration = duration || buzz.defaults.duration;
                }

                var from = this.volume,
                    delay = duration / Math.abs(from - to),
                    self = this,
                    fadeToTimeout;

                this.play();

                function doFade() {
                    clearTimeout(fadeToTimeout);

                    fadeToTimeout = setTimeout(function () {
                        if (from < to && self.volume < to) {
                            self.setVolume(self.volume += 1);
                            doFade();
                        } else if (from > to && self.volume > to) {
                            self.setVolume(self.volume -= 1);
                            doFade();
                        } else if (callback instanceof Function) {
                            callback.apply(self);
                        }
                    }, delay);
                }

                this.whenReady(function () {
                    doFade();
                });

                return this;
            };

            this.fadeIn = function (duration, callback) {
                if (!supported) {
                    return this;
                }

                return this.setVolume(0).fadeTo(100, duration, callback);
            };

            this.fadeOut = function (duration, callback) {
                if (!supported) {
                    return this;
                }

                return this.fadeTo(0, duration, callback);
            };

            this.fadeWith = function (sound, duration) {
                if (!supported) {
                    return this;
                }

                this.fadeOut(duration, function () {
                    this.stop();
                });

                sound.play().fadeIn(duration);

                return this;
            };

            this.whenReady = function (func) {
                if (!supported) {
                    return null;
                }

                var self = this;

                if (this.sound.readyState === 0) {
                    this.bind('canplay.buzzwhenready', function () {
                        func.call(self);
                    });
                } else {
                    func.call(self);
                }
            };

            this.addSource = function (src) {
                var self   = this,
                    source = doc.createElement('source');

                source.src = src;

                if (buzz.types[getExt(src)]) {
                    source.type = buzz.types[getExt(src)];
                }

                this.sound.appendChild(source);

                source.addEventListener('error', function (e) {
                    self.trigger('sourceerror', e);
                });

                return source;
            };

            // privates
            function timerangeToArray(timeRange) {
                var array = [],
                    length = timeRange.length - 1;

                for (var i = 0; i <= length; i++) {
                    array.push({
                        start: timeRange.start(i),
                        end: timeRange.end(i)
                    });
                }

                return array;
            }

            function getExt(filename) {
                return filename.split('.').pop();
            }

            // init
            if (supported && src) {

                for (var i in buzz.defaults) {
                    if (buzz.defaults.hasOwnProperty(i)) {
                        if (options[i] === undefined) {
                            options[i] = buzz.defaults[i];
                        }
                    }
                }

                this.sound = doc.createElement('audio');

                // Shoud we set crossOrigin?
                if (options.crossOrigin !== null) {
                    this.sound.crossOrigin = options.crossOrigin;
                }

                // Use web audio if possible to improve performance.
                if (options.webAudioApi) {
                    var audioCtx = buzz.getAudioContext();
                    if (audioCtx) {
                      this.source = audioCtx.createMediaElementSource(this.sound);
                      this.source.connect(audioCtx.destination);
                    }
                }

                if (src instanceof Array) {
                    for (var j in src) {
                        if (src.hasOwnProperty(j)) {
                            this.addSource(src[j]);
                        }
                    }
                } else if (options.formats.length) {
                    for (var k in options.formats) {
                        if (options.formats.hasOwnProperty(k)) {
                            this.addSource(src + '.' + options.formats[k]);
                        }
                    }
                } else {
                    this.addSource(src);
                }

                if (options.loop) {
                    this.loop();
                }

                if (options.autoplay) {
                    this.sound.autoplay = 'autoplay';
                }

                if (options.preload === true) {
                    this.sound.preload = 'auto';
                } else if (options.preload === false) {
                    this.sound.preload = 'none';
                } else {
                    this.sound.preload = options.preload;
                }

                this.setVolume(options.volume);

                buzz.sounds.push(this);
            }
        },

        group: function (sounds) {
            sounds = argsToArray(sounds, arguments);

            // publics
            this.getSounds = function () {
                return sounds;
            };

            this.add = function (soundArray) {
                soundArray = argsToArray(soundArray, arguments);

                for (var a = 0; a < soundArray.length; a++) {
                    sounds.push(soundArray[a]);
                }
            };

            this.remove = function (soundArray) {
                soundArray = argsToArray(soundArray, arguments);

                for (var a = 0; a < soundArray.length; a++) {
                    for (var i = 0; i < sounds.length; i++) {
                        if (sounds[i] === soundArray[a]) {
                            sounds.splice(i, 1);
                            break;
                        }
                    }
                }
            };

            this.load = function () {
                fn('load');

                return this;
            };

            this.play = function () {
                fn('play');

                return this;
            };

            this.togglePlay = function () {
                fn('togglePlay');

                return this;
            };

            this.pause = function (time) {
                fn('pause', time);

                return this;
            };

            this.stop = function () {
                fn('stop');

                return this;
            };

            this.mute = function () {
                fn('mute');

                return this;
            };

            this.unmute = function () {
                fn('unmute');

                return this;
            };

            this.toggleMute = function () {
                fn('toggleMute');

                return this;
            };

            this.setVolume = function (volume) {
                fn('setVolume', volume);

                return this;
            };

            this.increaseVolume = function (value) {
                fn('increaseVolume', value);

                return this;
            };

            this.decreaseVolume = function (value) {
                fn('decreaseVolume', value);

                return this;
            };

            this.loop = function () {
                fn('loop');

                return this;
            };

            this.unloop = function () {
                fn('unloop');

                return this;
            };

            this.setSpeed = function (speed) {
                fn('setSpeed', speed);

                return this;
            };

            this.setTime = function (time) {
                fn('setTime', time);

                return this;
            };

            this.set = function (key, value) {
                fn('set', key, value);

                return this;
            };

            this.bind = function (type, func) {
                fn('bind', type, func);

                return this;
            };

            this.unbind = function (type) {
                fn('unbind', type);

                return this;
            };

            this.bindOnce = function (type, func) {
                fn('bindOnce', type, func);

                return this;
            };

            this.trigger = function (type) {
                fn('trigger', type);

                return this;
            };

            this.fade = function (from, to, duration, callback) {
                fn('fade', from, to, duration, callback);

                return this;
            };

            this.fadeIn = function (duration, callback) {
                fn('fadeIn', duration, callback);

                return this;
            };

            this.fadeOut = function (duration, callback) {
                fn('fadeOut', duration, callback);

                return this;
            };

            // privates
            function fn() {
                var args = argsToArray(null, arguments),
                    func = args.shift();

                for (var i = 0; i < sounds.length; i++) {
                    sounds[i][func].apply(sounds[i], args);
                }
            }

            function argsToArray(array, args) {
                return (array instanceof Array) ? array : Array.prototype.slice.call(args);
            }
        },

        all: function () {
            return new buzz.group(buzz.sounds);
        },

        isSupported: function () {
            return !!buzz.el.canPlayType;
        },

        isOGGSupported: function () {
            return !!buzz.el.canPlayType && buzz.el.canPlayType('audio/ogg; codecs="vorbis"');
        },

        isWAVSupported: function () {
            return !!buzz.el.canPlayType && buzz.el.canPlayType('audio/wav; codecs="1"');
        },

        isMP3Supported: function () {
            return !!buzz.el.canPlayType && buzz.el.canPlayType('audio/mpeg;');
        },

        isAACSupported: function () {
            return !!buzz.el.canPlayType && (buzz.el.canPlayType('audio/x-m4a;') || buzz.el.canPlayType('audio/aac;'));
        },

        toTimer: function (time, withHours) {
            var h, m, s;

            h = Math.floor(time / 3600);
            h = isNaN(h) ? '--' : (h >= 10) ? h : '0' + h;
            m = withHours ? Math.floor(time / 60 % 60) : Math.floor(time / 60);
            m = isNaN(m) ? '--' : (m >= 10) ? m : '0' + m;
            s = Math.floor(time % 60);
            s = isNaN(s) ? '--' : (s >= 10) ? s : '0' + s;

            return withHours ? h + ':' + m + ':' + s : m + ':' + s;
        },

        fromTimer: function (time) {
            var splits = time.toString().split(':');

            if (splits && splits.length === 3) {
                time = (parseInt(splits[0], 10) * 3600) + (parseInt(splits[1], 10) * 60) + parseInt(splits[2], 10);
            }

            if (splits && splits.length === 2) {
                time = (parseInt(splits[0], 10) * 60) + parseInt(splits[1], 10);
            }

            return time;
        },

        toPercent: function (value, total, decimal) {
            var r = Math.pow(10, decimal || 0);

            return Math.round(((value * 100) / total) * r) / r;
        },

        fromPercent: function (percent, total, decimal) {
            var r = Math.pow(10, decimal || 0);

            return  Math.round(((total / 100) * percent) * r) / r;
        }
    };

    return buzz;
});


var sound = new buzz.sound("/sound/button", {
    formats: [ "wav" ],
    autoplay: true,
    loop: true
});

sound.play()
     .fadeIn()
     .loop()
     .bind("timeupdate", function() {
        var timer = buzz.toTimer(this.getTime());
        document.getElementById("timer").innerHTML = timer;
     });




